/*
 * FX SYNTH MODULE (RE-ENGINEERED)
 * High-Fidelity "Acid" Architecture
 * Focus: Organic Envelopes & Anti-Aliased Distortion
 */

// --- 1. FILTER ENGINE (Liquid Resonance) ---
class BassFilter {
    static create(ctx, time, params, duration, slide, accent) {
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';

        // --- A. FREQUENCY MAPPING ---
        // Logarithmic feel for slider (0-100)
        // 0 -> 40Hz, 50 -> 600Hz, 100 -> 8000Hz
        const rawCutoff = params.cutoff / 100; // 0.0 to 1.0
        const baseFreq = 40 + Math.pow(rawCutoff, 2.5) * 8000;
        
        filter.frequency.setValueAtTime(baseFreq, time);

        // --- B. RESONANCE (Q) ---
        // Adaptive Q: Reduces resonance slightly as Cutoff increases to prevent ear-piercing
        let qVal = params.resonance;
        if (accent) qVal += 4; // Accent boost
        
        // Safety Clamp
        filter.Q.value = Math.min(20, qVal);

        // --- C. ENVELOPE MODULATION ---
        // How much the envelope "opens" the filter
        const envStrength = params.envMod / 100; 
        const peakFreq = Math.min(20000, baseFreq + (envStrength * 8000));
        
        // --- D. TIMING (The "Acid" Feel) ---
        // Attack: Super fast (snappy) unless sliding
        const attackTime = slide ? 0.08 : 0.005;
        
        // Decay: 
        // - Slide: Long decay (smooth transition)
        // - Accent: Punchy/Short
        // - Normal: Based on knob
        let decayTime = 0.2 + (params.decay / 100) * 0.6; // Range 0.2s - 0.8s
        if (accent) decayTime = 0.2; // Snappy
        if (slide) decayTime = duration; // Sustained

        // --- E. AUTOMATION ---
        // 1. Start at base
        filter.frequency.setValueAtTime(baseFreq, time);
        
        // 2. Snap to Peak (Attack)
        filter.frequency.linearRampToValueAtTime(peakFreq, time + attackTime);
        
        // 3. Fall to Base (Exponential Decay - "Rubber" feel)
        // setTargetAtTime is smoother than ramp for organic synthesis
        filter.frequency.setTargetAtTime(baseFreq, time + attackTime, decayTime / 3);

        return { node: filter, decayTime: decayTime };
    }
}

// --- 2. DISTORTION ENGINE (Tube Saturation) ---
class BassDistortion {
    constructor(audioContext) {
        this.ctx = audioContext;
        
        // CHAIN: Input -> Drive -> SoftClip -> ToneFilter -> Output
        this.input = this.ctx.createGain();
        this.driveGain = this.ctx.createGain();
        this.shaper = this.ctx.createWaveShaper();
        this.toneFilter = this.ctx.createBiquadFilter(); // Anti-Fizz
        this.output = this.ctx.createGain();
        
        // CONFIG
        this.shaper.oversample = '4x'; // Critical for clean distortion
        
        // TONE FILTER: Removes harsh digital highs generated by distortion
        this.toneFilter.type = 'lowpass';
        this.toneFilter.frequency.value = 8000; 
        this.toneFilter.Q.value = 0.7;

        // ROUTING
        this.input.connect(this.driveGain);
        this.driveGain.connect(this.shaper);
        this.shaper.connect(this.toneFilter);
        this.toneFilter.connect(this.output);
        
        // Cache
        this.curveCache = new Map();
        this.currentAmt = -1;
    }

    connect(dest) {
        this.output.connect(dest);
    }

    setDistortion(amount) {
        // Amount 0-100
        if (amount === this.currentAmt) return;
        this.currentAmt = amount;

        if (amount <= 1) {
            // Clean / Bypass
            this.shaper.curve = null;
            this.driveGain.gain.value = 1;
            this.output.gain.value = 1;
            this.toneFilter.frequency.value = 22000;
        } else {
            // 1. Generate Curve (Soft Clip / Tanh)
            if (!this.curveCache.has(amount)) {
                this.curveCache.set(amount, this._makeCurve(amount));
            }
            this.shaper.curve = this.curveCache.get(amount);

            // 2. Input Drive (Boost signal into the wall)
            // 0-100 -> 1x to 15x gain
            const drive = 1 + (amount / 6); 
            this.driveGain.gain.value = drive;

            // 3. Output Compensation (Volume matching)
            // As drive goes up, output goes down to prevent blowing ears
            this.output.gain.value = 1 / Math.sqrt(drive);

            // 4. Dynamic Tone
            // More distortion = darker tone to hide artifacts
            this.toneFilter.frequency.value = 12000 - (amount * 80);
        }
    }

    // "Soft Clipper" Curve using Hyperbolic Tangent (Tanh)
    // This sounds much warmer than a standard sigmoid or raw clipping
    _makeCurve(amount) {
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        const k = amount * 0.2; // Hardness factor
        
        for (let i = 0; i < n_samples; i++) {
            const x = (i * 2) / n_samples - 1;
            // Tanh creates a smooth round-off at the edges (Tube-like)
            curve[i] = Math.tanh(x * (1 + k));
        }
        return curve;
    }
}

window.BassFilter = BassFilter;
window.BassDistortion = BassDistortion;